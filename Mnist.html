<!DOCTYPE html><html><head>
  <title>Pacifiky's Mnist</title>
  <style>
    html{color-scheme: dark;}
    body {
      padding: 0 5vw;
      color: #EEE;
      font-size: 20px;
      font-family: Tahoma, Arial, sans-serif;
      text-shadow: 0 5px 20px rgba(0,0,0,0.8);
      background: #222;
      overflow-x: hidden;
    }
    ::-webkit-scrollbar {width: 10px;}
    ::-webkit-scrollbar-track {
      background: #111;
   }
    ::-webkit-scrollbar-thumb {
      background: #666;
      border-radius: 10px;
    }
    ::-webkit-scrollbar-thumb:hover {background:#777;}
    ::-webkit-scrollbar-thumb:active {box-shadow: 0 0 10px white;}
    /*Begin PacifikyNeoDark*/
    :root {
      --hover: #4f4f4f;
      --border: 2px;
      --radius: 45px;
      --height: 6px;
    }
    input:focus,select:focus {outline:none;}
    input:active,select:active,input[type="text"]:focus,.button:active {background: linear-gradient(to left top, #292929, #121212)};
    .button,input,select {font-family: Tahoma, Arial, sans-serif;}
    input:active,select:active,input[type="text"]:focus,.button:active {
      box-shadow: 2px 2px var(--height) rgba(0,0,0,0.7) inset, -2px -2px var(--height) rgba(240,240,240,0.3) inset;
      border-color: rgba(0,0,0,0);
    }
    details,input,select,.button,.fp-grad-stop-cont-cont {border: var(--border) #292929 solid;box-shadow: 2px 2px var(--height) rgba(0,0,0,0.7), -2px -2px var(--height) rgba(240,240,240,0.3);}
    input,select {
      transition: box-shadow 500ms ease, border 500ms ease;
      background: linear-gradient(to left top, #121212, #292929);
      color: currentcolor;
      font-size: 13px;
      padding: 10px;
      margin: 2px;
      border-radius: var(--radius);
      min-width:0px;
    }
    select {background:#222}
    input:hover,select:hover,.button:hover {border-color: var(--hover);}
    .smallinput {width:10em}
    .button {
      display: inline-flex;
      flex-direction: row;
      justify-content: center;
      align-content: center;
      align-items: center;
      cursor: pointer;
      background: linear-gradient(to left top, #121212, #292929);
      color: currentColor;
      transition: box-shadow 500ms ease, border 500ms ease;
      font-size: 13px;
      padding: 8px;
      margin: 4px;
      border-radius: var(--radius);
      min-width: 100px;
    }
    .iconbutton {
      min-width: 0;
      width: 45px;
      height: 45px;
      font-size: 30px;
      border-radius: 50%;
      font-weight: bold;
      text-shadow: 0 0 5px rgba(0,0,0,0.5);
    }
    .icon {
      display: inline;
      height: 25px;
      width: 25px;
    }
    .smallbutton {min-width:5em;}
    details {
      border-radius: 20px;
      padding: 10px;
      margin: 10px;
      /*background: linear-gradient(to left top, #121212, #292929);*/
    }
    details[open] > summary {
      border-bottom: rgba(255,255,255,0.2) solid 2px;
      margin-bottom: 10px;
    }
    .gbtn {
      background: linear-gradient(135deg,#33ff33,#11c011);
      box-shadow: 2px 2px var(--height) rgba(0,0,0,0.8),-2px -2px var(--height) #33ff33;
      border-color:#11c011;
    }
    .gbtn:hover {border-color:#33ff33;}
    .gbtn:active {background: linear-gradient(-45deg,#33ff33,#11c011);box-shadow: inset 2px 2px var(--height) rgba(0,0,0,0.8),inset -2px -2px var(--height) #33ff33;}
    .rbtn {
      background: linear-gradient(135deg,#f95353,#a51212);
      box-shadow: 2px 2px var(--height) rgba(0,0,0,0.8),-2px -2px var(--height) #f95353;
      border-color: #a51212;
    }
    .rbtn:hover {border-color: #f95353}
    .rbtn:active {background: linear-gradient(-45deg,#f95353,#a51212);box-shadow: inset 2px 2px var(--height) rgba(0,0,0,0.8), inset -2px -2px var(--height) #f95353;}
    /*End PacifikyNeoDark*/
    .pabs {position:absolute;top:0;left:0;}
    .canvascont {display: inline-block;position:relative;width:500px;height:500px}
    input[type="color"] {padding:0;width:50px;height:35px;}
    .inline {display:inline}
    .hid {opacity:0;position:fixed;pointer-events:none;}
    .insect {margin: 10px 0}
    .flx-center {display:flex;flex-direction:column;align-content:center;justify-content:center;width:100%;justify-items:center;align-items:center;}
    .pad-5 {padding:10px;}
    hr {width:95%;border-color: #3d3d3d;margin:0 auto;}
    #tests {/*display:none*/}
    #mnistoutbot .prediction {
      font-size: 15px;
    }
    .thid {display:none;}
  </style>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width">
</head>

<body lang="en">
  <div id="controls">
  <div id="mnistouttop">
    <p class="mnistinfo">
      Activation: Leaky ReLU
      <br/>
      Hidden layer depth: 2
      <br/>
      Type: FF
      <br/>
      Connections: FCLs
      <br/>
      Loss: MSE
      <br/>
      Optimization: Mini Batch Gradient Descent
      <br/>
      OutActivation: Sigmoid
      <br/>
      Parameters: 52650
    </p>
    <!--<h3>784:64:32:10</h3>-->
    <h3 class="mniststatus">Loading train data, Calculating negative gradient, Randomizing weights/bias</h3>
  </div>
  <div class="topConpaint">
    <h3 class="ioutpaint">0,0</h3>
    <button class="iconpaint button">Clear</button>
    <button class="iconpaint button">Undo</button>
    <button class="iconpaint button">Redo</button>
    <button class="iconpaint button">Upload</button>
  </div>
  <div class="canvascont">
  <canvas width="28" height="28" style="width:500px;height:500px;"></canvas>
  </div>
  <!-- Storage inline as base64 (13mb + js), float64 (156250 floats), would be impractical so upload -->
  <div id="mnistoutbot">
    <div class="prediction">
      <h2 class="header">Prediction: Null</h2>
      <button class="button mnistpredictbtn">Predict</button>
      <h3 class="info">
        0: Null
        <br/>
        1: Null
        <br/>
        2: Null
        <br/>
        3: Null
        <br/>
        4: Null
        <br/>
        5: Null
        <br/>
        6: Null
        <br/>
        7: Null
        <br/>
        8: Null
        <br/>
        9: Null
      </h3>
    </div>
    <hr/>
    <div class="training">
      <h2>Training</h2>
      <h3 class="info">
        Current Epoch: Null 
        <br/>
        Loss: Null
      </h3>
      Interval (ms):
      <input type="number" min="0" value="10000" step='1' class='inttrainmnist'></input>
      <br/>
      Learn rate: 
      <input type="number" min="0" value="0.2" step='0.01' class='ratetrainmnist'></input>
      <br/>
      <button class="button sttrainmnist">Start Training</button>
      <button class="button sptrainmnist">Stop Training</button>
      <button class="button sitrainmnist">Train Step</button>
      <br/>
      <button class="button filebtnmnist">Upload Files</button>
      <br/>
      <h3>Uploaded Files:</h3>
      <p class="uploadedstat">× train-labels.idx1-ubyte<br/>× train-images.idx3-ubyte</p>
    </div>
    <hr/>
    <div class="testing">
      <h2>Testing</h2>
      <h3 class="info">
        Average Loss: Null
      </h3>
      <button class="button sttestmnist">Test</button>
      <br/>
      <button class="button filebtnmnist">Upload Files</button>
      <br/>
      <h3>Uploaded Files:</h3>
      <p class="uploadedstat">× t10k-labels.idx1-ubyte<br/>× t10k-images.idx3-ubyte</p>
    </div>
    <hr/>
    <div class="files">
      <h2>Manage NN</h2>
      <button class="button exportbtnmnist">Export NN</button>
      <button class="button importbtnmnist">Import NN</button>
    </div>
  </div>
  </div>
  <div id="tests" class="thid">
  <h2>Test</h2>
  <button id="testbtn">Start Test</button>
  <button id="testbtn2">Start Test2</button>
  <button id="testIDX">Start IDX</button>
  </div>
  <footer>Copyright 2025 Frost. All rights reserved.</footer>
</body><script>
    //class for draw
    //Setting direct commit don't need a layered system and also I need cool predictions
    class mfpaint {
      constructor(canv,inp2) {
        this.canvas = canv;
        this.canvas.classList.add("pabs");
        /*
        this.ccanvas = document.createElement("canvas");
        this.ccanvas.classList.add("pabs");
        this.ccanvas.width = this.canvas.width;
        this.ccanvas.height = this.canvas.height;
        this.canvas.parentNode.appendChild(this.ccanvas);
        this.ccanvas.style.pointerEvents = "none";
        this.ccanvas.style.width= this.canvas.style.width;
        this.ccanvas.style.height = this.canvas.style.height;
        */
        this.curcanvas = document.createElement("canvas");
        this.curcanvas.width = this.curcanvas.height = 100;
        this.ctx = this.canvas.getContext("2d",{willReadFrequently:true});
        //this.cctx = this.ccanvas.getContext("2d");
        this.curctx = this.curcanvas.getContext("2d");
        this.loadhistory = this.loadhistory.bind(this);
        this.loadhistory2 = this.loadhistory2.bind(this);
        this.uploadFil = this.uploadFil.bind(this);
        this.clr = "#FFFFFF";
        this.md = false;
        this.softness = 1.0;
        this.opacity = 255;
        this.strokesize = 2;
        this.step = 1;
        this.paint = this.paint.bind(this);
        this.clear = this.clear.bind(this);
        this.prevloc = [0,0];
        this.history = [];
        this.history2 = [];
        //mar:canvasmouse
        this.canvas.parentNode.addEventListener("mousedown",e=>{e.preventDefault();
          document.body.focus();
          //document.body.click();
          this.md = true;
          this.prevloc = [Math.floor(e.offsetX*(this.canvas.width/parseInt(this.canvas.style.width))),Math.floor(e.offsetY*(this.canvas.height/parseInt(this.canvas.style.height)))];
          this.savehistory();
          this.paint(e)
        });
        this.canvas.parentNode.addEventListener("mousemove",this.paint);
        this.canvas.parentNode.addEventListener("mouseup",e=>{
          this.md = false;
          //this.commit();
        });
        //EVENTS
        if(inp2){
        this.topinp = inp2.getElementsByClassName("iconpaint");
        this.topoup = inp2.getElementsByClassName("ioutpaint");
        this.topinp[0].addEventListener("click",this.clear);
        this.topinp[1].addEventListener("click",this.loadhistory);
        this.topinp[2].addEventListener("click",this.loadhistory2);
        this.topinp[3].addEventListener("click",this.uploadFil)
        }
        this.canvas.style.imageRendering = "pixelated"; //this.ccanvas.style.imageRendering
        this.updstroke();
        document.addEventListener("keydown",this._checkKey);
        this.ctx.fillStyle="#000000"
        this.ctx.fillRect(0,0,this.canvas.width,this.canvas.height);
      }
      //mar:paint
      paint(e) {
        const realX = Math.floor(e.offsetX*(this.canvas.width/parseInt(this.canvas.style.width)));
        const realY = Math.floor(e.offsetY*(this.canvas.height/parseInt(this.canvas.style.height)));
        this.topoup[0].innerText = realX + "," + realY;
        if(this.md){
          let contextused = this.ctx;
          let alphaused = 255;
          if(realX==this.prevloc[0] && realY==this.prevloc[1]){
            let stroke = contextused.createRadialGradient(realX,realY,0,realX,realY,this.strokesize);
            stroke.addColorStop(1-this.softness,this.clr+alphaused.toString(16).padEnd(2,"0"));
            stroke.addColorStop(1,this.clr+"00");
            contextused.fillStyle = stroke;
            contextused.fillRect(0,0,this.canvas.width,this.canvas.height);
          } else {
            //intdiv dist by 5 
            //for the amount of 5ves go into the dist.
            //multiply nvect by 5 
            //use ^ var then mult by index (start at 1 on for loop)
            //add to ploc
            //set ploc to last stroke.
            let nvect = [realX-this.prevloc[0],realY-this.prevloc[1]];
            const dist = Math.sqrt(nvect[0]**2 + nvect[1]**2);
            nvect = nvect.map(i=>i/dist);
            const amountofstep = Math.floor(dist/this.step);
            for(let i=1;i<=amountofstep;i++){
              const npos = [this.prevloc[0]+nvect[0]*(this.step*i),this.prevloc[1]+nvect[1]*(this.step*i)];
              let stroke = contextused.createRadialGradient(npos[0],npos[1],0,npos[0],npos[1],this.strokesize);
              stroke.addColorStop(1-this.softness,this.clr+alphaused.toString(16).padEnd(2,"0"));
              stroke.addColorStop(1,this.clr+"00");
              contextused.fillStyle = stroke;
              contextused.fillRect(0,0,this.canvas.width,this.canvas.height);
              if(i==amountofstep){this.prevloc = npos};
            }
          }
        };
        return;
      }
      hex2rgb(s) {if(s.length > 7){return Uint8Array.of(parseInt(s.substring(1,3),16),parseInt(s.substring(3,5),16),parseInt(s.substring(5,7),16),parseInt(s.substring(7,9),16))}else{return Uint8Array.of(parseInt(s.substring(1,3),16),parseInt(s.substring(3,5),16),parseInt(s.substring(5,7),16),255)};}
      rgb2hex(a) {return "#" + a[0].toString(16).padStart(2,"0") + a[1].toString(16).padStart(2,"0") + a[2].toString(16).padStart(2,"0")}
      clear(e) {this.ctx.fillStyle="#000000";this.ctx.fillRect(0,0,this.canvas.width,this.canvas.height);}
      updstroke() {
        this.curctx.clearRect(0,0,100,100);
        this.curctx.fillStyle = "white";
        this.curctx.fillRect(48,48,5,5);
        this.curctx.fillStyle = "black";
        this.curctx.fillRect(49,49,3,3);
        const realstroke = Math.floor(this.strokesize*(parseInt(this.canvas.style.height)/this.canvas.height));
        this.curctx.strokeStyle = this.clr+this.opacity.toString(16);
        this.curctx.beginPath();
        this.curctx.arc(50,50,realstroke,0,2*Math.PI);
        this.curctx.stroke();
        this.curctx.closePath();
        this.updtool();
      }
      updtool() {
        this.canvas.parentNode.style.cursor = 'url("'+this.curcanvas.toDataURL()+'") 50 50,default';
      }
      savehistory() {
        this.history.push(this.ctx.getImageData(0,0,this.canvas.width,this.canvas.height));
      }
      loadhistory() {
        if(this.history.length > 0){
          this.history2.push(this.ctx.getImageData(0,0,this.canvas.width,this.canvas.height));
          this.ctx.putImageData(this.history.pop(),0,0);
        } else {
          this.clear(null);
        }
      }
      loadhistory2() {
        if(this.history2.length > 0){
          this.history.push(this.ctx.getImageData(0,0,this.canvas.width,this.canvas.height));
          this.ctx.putImageData(this.history2.pop(),0,0);
        }
      }
      _checkKey(e) {
        if(e.ctrlKey){
          switch(e.key){
            case "z":
              this.loadhistory();
              break;
            case "Z":
              this.loadhistory2();
              break;
            case "d":
              this.selection[0] = false;
              this.commit();
              break;
          }
        }
      }
      /*
      commit() {
        this.ctx.globalAlpha = this.opacity/255;
        //Add clip code
        this.ctx.drawImage(this.ccanvas,0,0);
        this.cctx.clearRect(0,0,this.ccanvas.width,this.ccanvas.height);
        return;
      }
      */
      uploadFil(e) {
        const fin = document.createElement("input");
        fin.setAttribute("type","file");
        fin.setAttribute("accept","image/*");
        fin.addEventListener("change",e=>{
          const url = URL.createObjectURL(fin.files[0])
          let img = new Image();
          img.onload = () => {
            this.savehistory();
            URL.revokeObjectURL(url);
            //this.ctx.setTransform(this.transformmtx[0],this.transformmtx[1],this.transformmtx[2],this.transformmtx[3],this.transformmtx[4],this.transformmtx[5]);
            //this.ctx.filter = this.getFil();
            this.ctx.drawImage(img,0,0);
            //this.ctx.resetTransform();
            //this.ctx.filter = "";
            //this.commit();
          }
          img.src = url;
        })
        fin.click();
      }
    }
    class NeuralJS {
      static Loss = class Loss {
        static mse(itsr,otsr){
          if(itsr.length != otsr.length){throw RangeError("Input and Output lengths in MSE are unequal!")}
          let err = 0;
          for(let i=0;i<itsr.length;i++){
            err += (itsr[i]-otsr[i])**2;
          }
          return err/itsr.length;
        }
      }
      static Activation = class Activation {
        static reLU(tensor){
          for(let i=0;i<tensor.length;i++){
            tensor[i] = Math.max(tensor[i],0);
          }
          return tensor;
        }
        static sigmoid(tensor){
          for(let i=0;i<tensor.length;i++){
            tensor[i] = 1/(1+Math.exp(-tensor[i])); // (Math.E**-tensor[i])
          }
          return tensor;
        }
        static lreLU(tensor,a){
          for(let i=0;i<tensor.length;i++){
            if(tensor[i] <= 0){
              tensor[i] = a*tensor[i];
            }
          }
          return tensor;
        }
        static tanh(tensor){
          for(let i=0;i<tensor.length;i++){
            tensor[i] = Math.tanh(tensor[i]);
          }
          return tensor;
        }
        static step(tensor,a){
          for(let i=0;i<tensor.length;i++){
            tensor[i] = tensor[i]>=a;
          }
          return tensor;
        }
      }
      static Layer = class Layer {
        constructor(wlen,blen){
          this.weights = new Float32Array(wlen);
          this.biases = new Float32Array(blen);
        }
        randVals(wran=1,bran=1){
          //Randomize w/b
          for(let i=0;i<this.weights.length;i++){
            this.weights[i] = (Math.random()*(wran*2))-wran;
          }
          for(let i=0;i<this.biases.length;i++){
            this.biases[i] = (Math.random()*(bran*2))-bran;
          }
        }
        static Linear = class Linear extends Layer{
          constructor(inum,onum){
            super(inum*onum,onum);
            this.incount = inum;
            this.outcount = onum;
          }
          compute(tensor){
            //console.log(tensor);
            //console.log(tensor.length.toString() + " " + this.incount);
            if(tensor.length != this.incount){throw RangeError("Layer input length is not equal to the input count of the Linear transformation!")};
            let otensor = new Float32Array(this.outcount);
            for(let j=0;j<this.outcount;j++){
              for(let i=0;i<tensor.length;i++){
                otensor[j] += tensor[i]*this.weights[(j*this.incount)+i];
              }
              otensor[j] += this.biases[j];
            }
            return otensor;
          }
        }
      }
      static Network = class Network {
        constructor(shape,options){
          //enum activation 0:Sigmoid 1:ReLU 2:LReLU 3:Tanh 4:Step 5:ELU
          //enum loss 0:MSE 1:CROSSENTROPY
          //enum opti 0:SGD 1: BGD 2: MBGD
          //enum oactiv 0:Softmax 1:Linear 2:Sigmoid
          this.learnRate = options.learnRate ?? 0.2;
          this.activation = options.activation ?? 0;
          switch(this.activation){
            case 2:
              if(!options.lreluA){console.warn("LeakyRELU activation network missing alpha option, setting default!")};
              this.lreluA = options.lreluA ?? 0.2;
              break;
            case 4:
              if(!options.stepA){console.warn("Step activation network missing alpha option, setting default!")};
              this.stepA = options.stepA ?? 2;
              break;
          }
          this.oActiv = options.oActiv ?? 0;
          this.loss = options.loss ?? 0;
          this.opti = options.opti ?? 0;
          //mgsize waz here
          this.shape = shape;
        }
        randAll(wran=1,bran=1){
          for(let i=0;i<this.shape.length;i++){this.shape[i].randVals(wran,bran);}
        }
        forward(itensor,mode=0){
          let otensor = itensor;
          let totalneuron = 0;
          /*
          for(let i=0;i<this.shape.length;i++){totalneuron += this.shape[i].outcount;};
          let atable = new Float32Array(totalneuron);
          //let ztable = new Float32Array(totalneuron); 
          */
          let atable = new Array(this.shape.length);
          //let ztable = []; ZTABLE nott needed because both softmax and sigmoid derivatives only req output
          let skpcnt = 0;
          for(let i=0;i<this.shape.length;i++){
            otensor = this.shape[i].compute(otensor);
            //ztable.push(otensor.slice());
            if(i<this.shape.length-1){
              switch(this.activation){
                case 0:
                  otensor = NeuralJS.Activation.sigmoid(otensor);
                  break;
                case 1:
                  otensor = NeuralJS.Activation.reLU(otensor);
                  break;
                case 2:
                  otensor = NeuralJS.Activation.lreLU(otensor,this.lreluA);
                  break;
                case 3:
                  otensor = NeuralJS.Activation.tanh(otensor);
                  break;
                case 4:
                  otensor = NeuralJS.Activation.step(otensor,this.stepA);
                  break;
              }
            }else{
              switch(this.oActiv){
                case 0:
                  break;
                case 2:
                  otensor = NeuralJS.Activation.sigmoid(otensor);
                  break;
              }
            }
            switch(mode){
              case 1:
                atable[i] = otensor.slice();
            }
            //console.log(otensor)
          }
          switch(mode){
            case 1:
              return [otensor,atable];
            default:
              return otensor;
          }
          //return [otensor,atable]; //atale and ztable is equal to shape length. ++ ztable not req
        }
        backprop(mode=0,itensor,ptensor,sdeltaw=Array.from({length:this.shape.length},(_,ind)=>new Float32Array(this.shape[ind].weights.length)),sdeltab=Array.from({length:this.shape.length},(_,ind)=>new Float32Array(this.shape[ind].biases.length))){
          const [otensor,atable] = this.forward(itensor,1);
          let deltaa = [];
          const loss = this.loss ? 0 : NeuralJS.Loss.mse(otensor,ptensor);
          switch(this.loss){
            case 0:
              let deltapa = new Float32Array(otensor.length); //Previous activation gradient
              const dmconst = 2/otensor.length; //The constant in the derivative thing;
              for(let i=0;i<otensor.length;i++){
                deltapa[i] = dmconst*(otensor[i]-ptensor[i]); //gradient
              };
              for(let i=this.shape.length-1;i>=0;i--){
                //We should calculate learnrate and negative gradient at commit of deltatables.
                deltaa = new Float32Array(this.shape[i].incount); //idk
                for(let j=0;j<deltapa.length;j++){
                  if(i == this.shape.length-1){
                    switch(this.oActiv){
                      case 0:{
                        break;
                      }
                      case 1:{
                        //bias derivative is cost.
                        sdeltab[i][j] += deltapa[j];
                        const wrow = this.shape[i].incount*j; 
                        const prevact = i==0 ? itensor : atable[i-1];
                        for(let k=0;k<this.shape[i].incount;k++){
                          sdeltaw[i][wrow+k] += deltapa[j]*prevact[k];
                          deltaa[k] += deltapa[j]*this.shape[i].weights[wrow+k]; //Because all outputs are dependent on this activation, we calculate sum of the gradients for the derivative of the cost.
                        }
                        break;
                      }
                      case 2:{
                        const deltasig = atable[i][j]*(1-atable[i][j]);
                        sdeltab[i][j] += deltapa[j]*deltasig;
                        const wrow = this.shape[i].incount*j; 
                        const prevact = i==0 ? itensor : atable[i-1];
                        for(let k=0;k<this.shape[i].incount;k++){
                          sdeltaw[i][wrow+k] += deltapa[j]*deltasig*prevact[k];
                          deltaa[k] += deltapa[j]*deltasig*this.shape[i].weights[wrow+k];
                        }
                        break;
                      }
                    }
                  }else{
                    switch(this.activation){
                      case 0:{
                        //same as outact 2
                        const deltasig = atable[i][j]*(1-atable[i][j]);
                        sdeltab[i][j] += deltapa[j]*deltasig;
                        const wrow = this.shape[i].incount*j;
                        const prevact = i==0 ? itensor : atable[i-1];
                        for(let k=0;k<this.shape[i].incount;k++){
                          sdeltaw[i][wrow+k] += deltapa[j]*deltasig*prevact[k];
                          deltaa[k] += deltapa[j]*deltasig*this.shape[i].weights[wrow+k];
                        }
                        break;
                      }
                      case 1:{
                        if(atable[i][j] > 0){ //erm dying relu 😨
                          sdeltab[i][j] += deltapa[j];
                          const wrow = this.shape[i].incount*j;
                          const prevact = i==0 ? itensor : atable[i-1];
                          for(let k=0;k<this.shape[i].incount;k++){
                            sdeltaw[i][wrow+k] += deltapa[j]*prevact[k];
                            deltaa[k] += deltapa[j]*this.shape[i].weights[wrow+k];
                          }
                        }
                        break;
                      }
                      case 2:{
                        const deltaact = atable[i][j] > 0 ? this.lreluA : 1; //yey no more dying
                        sdeltab[i][j] += deltapa[j]*deltaact;
                        const wrow = this.shape[i].incount*j;
                        const prevact = i==0 ? itensor : atable[i-1];
                        for(let k=0;k<this.shape[i].incount;k++){
                          sdeltaw[i][wrow+k] += deltapa[j]*deltaact*prevact[k];
                          deltaa[k] += deltapa[j]*deltaact*this.shape[i].weights[wrow+k];
                        }
                        break;
                      }
                      case 3:{
                        //1/Math.cosh(x)**2 for tanh derivative
                        break;
                      }
                      case 4:{
                        //Could be approximated through 1/1+exp(-1000(x+n)) however, i'm lazy
                        break;
                      }
                      case 5:{
                        break;
                      }
                    }
                  }
                }
                deltapa = deltaa;
              }
              break;
            case 1:
              break;
          }
          switch(mode){
            case 0:
              return [sdeltaw,sdeltab];
              break;
            case 1:
              return [sdeltaw,sdeltab,deltaa];
              break;
            case 2:
              return [sdeltaw,sdeltab,loss];
              break;
          }
        }
        train(ttensor,mode=0){
          //Sigmoid derivative: s(x)(1-s(x))
          //ReLU/Lrelu derivative: x>0 ? 1 : 1*a || 0
          //MSE derivative: 2/n (y-yhat)
          //Before optimizing the optimizer (lol) i'm making this rough draft.
          switch(this.opti){
            case 0:{
              //sgd ttensor = [itensor,ptensor]
              let [deltaw,deltab,ext] = this.backprop(mode,ttensor[0],ttensor[1]);
              for(let i=0;i<this.shape.length;i++){
                for(let j=0;j<this.shape[i].weights.length;j++){this.shape[i].weights[j] -= this.learnRate*deltaw[i][j];};
                for(let j=0;j<this.shape[i].biases.length;j++){this.shape[i].biases[j] -= this.learnRate*deltab[i][j];};
              };
              switch(mode){
                case 1:
                case 2:
                  return ext;
              }
              break;
            }
            case 1:{
              //Batch GD format: [[intensor...],[ptensor...]]
              if(ttensor[0].length != ttensor[1].length){throw RangeError("input tensor and predicted tensor arrays have a length mismatch!")};
              let sdeltaw = Array.from({length:this.shape.length},(_,ind)=>new Float32Array(this.shape[ind].weights.length)); //should have weight gradient (not neg) for each layer (each layer as f32array?) 
              let sdeltab = Array.from({length:this.shape.length},(_,ind)=>new Float32Array(this.shape[ind].biases.length)); //bias same as ^^
              let losssum = 0;
              let ngrad;
              for(let eind=0;eind<ttensor[0].length;eind++){
                switch(mode){
                  case 0:
                    [sdeltaw,sdeltab] = this.backprop(mode,ttensor[0][eind],ttensor[1][eind],sdeltaw,sdeltab);
                    break;
                  case 1:
                    if(eind == ttensor[0].length-1){
                      [sdeltaw,sdeltab,ngrad] = this.backprop(mode,ttensor[0][eind],ttensor[1][eind],sdeltaw,sdeltab);
                    }else{
                      [sdeltaw,sdeltab] = this.backprop(mode,ttensor[0][eind],ttensor[1][eind],sdeltaw,sdeltab);
                    }
                    break;
                  case 2:
                    let ext = 0;
                    [sdeltaw,sdeltab,ext] = this.backprop(mode,ttensor[0][eind],ttensor[1][eind],sdeltaw,sdeltab);
                    losssum += ext;
                    break;
                }
              }
              for(let i=0;i<this.shape.length;i++){
                for(let j=0;j<this.shape[i].weights.length;j++){this.shape[i].weights[j] -= this.learnRate*(sdeltaw[i][j]/ttensor[0].length)};
                for(let j=0;j<this.shape[i].biases.length;j++){this.shape[i].biases[j] -= this.learnRate*(sdeltab[i][j]/ttensor[0].length)};
              }
              switch(mode){
                case 1:
                  return ngrad;
                  break;
                case 2:
                  return losssum/ttensor[0].length;
                  break;
              };
              break;
            }
            case 2:{
              //MBGD format: [[itensor...],[ptensor...],size] REMOVE THE FLIPPING PROPERTY
              if(ttensor[0].length != ttensor[1].length){throw RangeError("input tensor and predicted tensor arrays have a length mismatch!")};
              if(ttensor[0].length%ttensor[2] != 0){console.warn("Tensor length isn't divisible by batch size, last examples will automatically commit.");};
              let sdeltaw = Array.from({length:this.shape.length},(_,ind)=>new Float32Array(this.shape[ind].weights.length)); //should have weight gradient (not neg) for each layer (each layer as f32array?) 
              let sdeltab = Array.from({length:this.shape.length},(_,ind)=>new Float32Array(this.shape[ind].biases.length)); //bias same as ^^
              let iteminc = 1;
              let losssum = 0;
              let ngrad;
              for(let eind=0;eind<ttensor[0].length;eind++){
                let loss = 0;
                switch(mode){
                  case 0:
                    [sdeltaw,sdeltab] = this.backprop(mode,ttensor[0][eind],ttensor[1][eind],sdeltaw,sdeltab);
                    break;
                  case 1:
                    if(eind==ttensor[0].length-1){
                      [sdeltaw,sdeltab,ngrad] = this.backprop(mode,ttensor[0][eind],ttensor[1][eind],sdeltaw,sdeltab);
                    }else{
                      [sdeltaw,sdeltab] = this.backprop(mode,ttensor[0][eind],ttensor[1][eind],sdeltaw,sdeltab);
                    }
                    break;
                  case 2:
                    [sdeltaw,sdeltab,loss] = this.backprop(mode,ttensor[0][eind],ttensor[1][eind],sdeltaw,sdeltab);
                    //eind%ttensor[2]
                    losssum += loss;
                    break;
                };
                if(iteminc==ttensor[2] || eind==ttensor[0].length){
                  //console.log(eind);
                  for(let i=0;i<this.shape.length;i++){
                    for(let j=0;j<this.shape[i].weights.length;j++){this.shape[i].weights[j] -= this.learnRate*(sdeltaw[i][j]/iteminc);sdeltaw[i][j]=0;};
                    for(let j=0;j<this.shape[i].biases.length;j++){this.shape[i].biases[j] -= this.learnRate*(sdeltab[i][j]/iteminc);sdeltab[i][j]=0;};
                  };
                  iteminc = 1;
                }else{
                  iteminc++;
                };
              }
              switch(mode){
                case 1:
                  return ngrad;
                case 2:
                  return losssum/ttensor[0].length;
              }
              break;
            }
          };
        };
      }
      static File = class File {
        static importNN(data){
          const params = {activation:0,oActiv:0};
          const dv = new DataView(data);
          if(dv.getUint16(0) != 0 && dv.getUint16(2) != 0){
            return null;
          };
          let cursor = 4;
          params.activation = dv.getUint8(cursor);
          cursor+=1;
          params.oActiv = dv.getUint8(cursor);
          cursor+=1;
          const shape = new Array(dv.getUint16(cursor));
          cursor+=2;
          for(let i=0;i<shape.length;i++){
            shape[i] = new NeuralJS.Layer.Linear(dv.getUint32(cursor),dv.getUint32(cursor+4));
            cursor+=4;
          }
          cursor+=4;
          for(let i=0;i<shape.length;i++){
            for(let j=0;j<shape[i].weights.length;j++){
              shape[i].weights[j] = dv.getFloat32(cursor);
              cursor+=4;
            }
            //alert(cursor);
            for(let j=0;j<shape[i].biases.length;j++){
              shape[i].biases[j] = dv.getFloat32(cursor);
              cursor+=4;
            }
          }
          return new NeuralJS.Network(shape,params);
        }
        static exportNN(net){
          //length = 4+4*(shape.length)
          let totalp = 0;
          for(let i=0;i<net.shape.length;i++){
            totalp += net.shape[i].weights.length + net.shape[i].biases.length;
          }
          const head = new ArrayBuffer(12+4*net.shape.length+4*totalp);
          //console.log(12+4*net.shape.length+4*totalp);
          const hdv = new DataView(head);
          //hdv.setUint16(0,0); //version
          //hdv.setUint16(2,0); //type
          hdv.setUint32(0,0);
          let cursor = 4;
          hdv.setUint8(cursor,net.activation);
          cursor+=1;
          hdv.setUint8(cursor,net.oActiv);
          cursor+=1;
          hdv.setUint16(cursor,net.shape.length);
          cursor+=2;
          hdv.setUint32(cursor,net.shape[0].incount);
          cursor+=4
          for(let i=0;i<net.shape.length;i++){
            hdv.setUint32(cursor,net.shape[i].outcount);
            cursor+=4;
          }
          //const params = new Array(net.shape.length);
          for(let i=0;i<net.shape.length;i++){
            //params[i] = new ArrayBuffer(net.shape[i].biases.length + net.shape[i].weights.length); //const layer
            //const ldv = new DataView(layer);
            //let lcur = 0;
            for(let j=0;j<net.shape[i].weights.length;j++){
              hdv.setFloat32(cursor,net.shape[i].weights[j]);
              cursor += 4;
            }
            //alert(cursor);
            for(let j=0;j<net.shape[i].biases.length;j++){
              hdv.setFloat32(cursor,net.shape[i].biases[j]);
              cursor += 4;
            }
          }
          return head;
        }
      }
    }
    //put 
    class IDXReader{
      constructor(data){
        //Data is arraybuffer
        this.data = new DataView(data);
        this.vdata = true;
        if(this.data.getInt16(0) != 0){
          alert("Invalid IDX data missing header!");
          this.vdata = false;
        };
        this.type = this.data.getInt8(2);
        this.dimnum = this.data.getInt8(3);
        this.dim = new Int32Array(this.dimnum);
        this.datalength = 1;
        for(let i=0;i<this.dimnum;i++){
          this.dim[i] = this.data.getUint32(4+(i*4));
          this.datalength *= this.dim[i];
        };
        this.datastart = 4+(this.dimnum*4);
      }
      getTensor(){
        let cursor = this.datastart;
        let dataArr = null;
        switch(this.type){
          case 8:
            dataArr = new Uint8Array(this.datalength);
            for(let i=0;i<this.datalength;i++){
              dataArr[i] = this.data.getUint8(cursor);
              cursor++;
            }
            break;
          case 9:
            dataArr = new Int8Array(this.datalength);
            for(let i=0;i<this.datalength;i++){
              dataArr[i] = this.data.getInt8(cursor);
              cursor++;
            };
            break;
          case 11:
            dataArr = new Int16Array(this.datalength);
            for(let i=0;i<this.datalength;i++){
              dataArr[i] = this.data.getInt16(cursor);
              cursor+=2;
            }
            break;
          case 12:
            dataArr = new Int32Array(this.datalength);
            for(let i=0;i<this.datalength;i++){
              dataArr[i] = this.data.getInt32(cursor);
              cursor+=4;
            }
            break;
          case 13:
            dataArr = new Float32Array(this.datalength);
            for(let i=0;i<this.datalength;i++){
              dataArr[i] = this.data.getFloat32(cursor);
              cursor+=4;
            }
            break;
          case 14:
            dataArr = new Float64Array(this.datalength);
            for(let i=0;i<this.datalength;i++){
              dataArr[i] = this.data.getFloat64(cursor);
              cursor+=8;
            }
            break;
          default:
            alert("Invalid IDX data invalid type!")
            this.vdata = false;
            break;
        };
        //Reshape
        return this.reshape(dataArr,this.dim.reverse(),this.type);
      }
      reshape(a,dim,type){
        if(dim.length == 1){
          if(dim[0] != a.length){
            console.warn("Array is not directly divisible for the dim, flooring");amt = Math.floor(amt);
            let narr = Array.from(a);
            narr.length = dim[0];
            switch(this.type){
              case 8:
                return Uint8Array.from(narr);
                break;
              case 9:
                return Int8Array.from(narr);
                break;
              case 11:
                return Int16Array.from(narr);
                break;
              case 12:
                return Int32Array.from(narr);
                break;
              case 13:
                return Float32Array.from(narr);
                break;
              case 14:
                return Float64Array.from(narr);
                break;
              default:
                alert("Invalid IDX data invalid type!")
                break;
            };
          }else{
            return a;
          }
        }
        let narr = Array.from(a);
        for(let i=0;i<dim.length-1;i++){
          let amt = narr.length/dim[i];
          if(amt-Math.floor(amt) > 0){console.warn("Array is not directly divisible for the dim, flooring");amt = Math.floor(amt);};
          let oarr = new Array(amt);
          if(i == 0){
            switch(this.type){
              case 8:
                for(let j=0;j<amt;j++){
                  oarr[j] = Uint8Array.from(narr.slice(j*dim[i],(j+1)*dim[i]));
                }
                  break;
              case 9:
                for(let j=0;j<amt;j++){
                  oarr[j] = Int8Array.from(narr.slice(j*dim[i],(j+1)*dim[i]));
                }
                break;
              case 11:
                for(let j=0;j<amt;j++){
                  oarr[j] = Int16Array.from(narr.slice(j*dim[i],(j+1)*dim[i]));
                }
                break;
              case 12:
                for(let j=0;j<amt;j++){
                  oarr[j] = Int32Array.from(narr.slice(j*dim[i],(j+1)*dim[i]));
                }
                break;
              case 13:
                for(let j=0;j<amt;j++){
                  oarr[j] = Float32Array.from(narr.slice(j*dim[i],(j+1)*dim[i]));
                }
                break;
              case 14:
                for(let j=0;j<amt;j++){
                  oarr[j] = Float64Array.from(narr.slice(j*dim[i],(j+1)*dim[i]));
                }
                break;
              default:
                alert("Invalid IDX data invalid type!")
                break;
            };
          }else{
            for(let j=0;j<amt;j++){
              oarr[j] = narr.slice(j*dim[i],(j+1)*dim[i]);
            }
          }
          narr = oarr;
        }
        if(narr.length != dim[dim.length-1]){console.warn("Array is not the same length as dim!")}
        return narr;
      }
      getDimArr(){
        return this.dim;
      }
      getType(){
        return this.type;
      }
      getDataLength(){
        return this.datalength;
      }
    }
    
    //A front-back sys would be tedious and annoying lol
    class Mnist {
      constructor(meta,tr,paint){
        this.paint = paint;
        this.trainsect = tr.getElementsByClassName("training")[0];
        this.testsect = tr.getElementsByClassName("testing")[0];
        this.predsect = tr.getElementsByClassName("prediction")[0];
        this.filesect = tr.getElementsByClassName("files")[0];
        this.upltrainbtn = this.trainsect.getElementsByClassName("filebtnmnist")[0];
        this.upltestbtn = this.testsect.getElementsByClassName("filebtnmnist")[0];
        this.expbtn = this.filesect.getElementsByClassName("exportbtnmnist")[0];
        this.impbtn = this.filesect.getElementsByClassName("importbtnmnist")[0];
        this.trainstat = this.trainsect.getElementsByClassName("uploadedstat")[0];
        this.teststat = this.testsect.getElementsByClassName("uploadedstat")[0];
        this.trainupl = this.trainupl.bind(this);
        this.testupl = this.testupl.bind(this);
        this.statTest = this.statTest.bind(this);
        this.stopTrain = this.stopTrain.bind(this);
        this.statTrain = this.statTrain.bind(this);
        this.train = this.train.bind(this);
        this.updEngine = this.updEngine.bind(this);
        this.evalNum = this.evalNum.bind(this);
        this.updRate = this.updRate.bind(this);
        this.exportNN = this.exportNN.bind(this);
        this.importNN = this.importNN.bind(this);
        this.trainst = this.trainsect.getElementsByClassName("sttrainmnist")[0];
        this.trainsp = this.trainsect.getElementsByClassName("sptrainmnist")[0];
        this.trainsi = this.trainsect.getElementsByClassName("sitrainmnist")[0];
        this.trainint = this.trainsect.getElementsByClassName("inttrainmnist")[0];
        this.traininp = this.trainsect.getElementsByClassName("ratetrainmnist")[0];
        this.traininfo = this.trainsect.getElementsByClassName("info")[0]; 
        this.testbtn = this.testsect.getElementsByClassName("sttestmnist")[0];
        this.testinf = this.testsect.getElementsByClassName("info")[0];
        this.predbtn = this.predsect.getElementsByClassName("mnistpredictbtn")[0];
        this.predinfo = this.predsect.getElementsByClassName("info")[0]; 
        this.predhead = this.predsect.getElementsByClassName("header")[0];
        this.info = meta.getElementsByClassName("mnistinfo")[0];
        this.status = meta.getElementsByClassName("mniststatus")[0];
        //values
        this.status.innerText = "Randomizing weights...";
        this.engineMod = new NeuralJS.Network([new NeuralJS.Layer.Linear(784,64),new NeuralJS.Layer.Linear(64,32),new NeuralJS.Layer.Linear(32,10)],{activation:0,oActiv:2,opti:2});
        this.trainMod = new NeuralJS.Network([new NeuralJS.Layer.Linear(784,64),new NeuralJS.Layer.Linear(64,32),new NeuralJS.Layer.Linear(32,10)],{activation:0,oActiv:2,opti:2,learnRate:0.1});
        this.trainMod.randAll(1,1); //0-centered 1 vals are more beneficial than higher lol
        this.updEngine();
        //Train images use 28x28 arrays, deconstruct.
        this.traindat = new Array(2);//(2tensors) [train-label,train-images]
        this.testdat = new Array(2);//(2tensor) [t10-label,t10k-image]
        this.traininp.value = this.trainMod.learnRate.toString();
        this.process = -1;
        this.epoch = 0;
        //try{
        this.updStats();
        //}catch(e){alert(e.stack)}
        //EVTINIT
        this.status.innerText = "Initializing Events...";
        this.upltrainbtn.addEventListener("click",this.trainupl);
        this.upltestbtn.addEventListener("click",this.testupl);
        this.testbtn.addEventListener("click",this.statTest);
        this.trainsp.addEventListener("click",this.stopTrain);
        this.trainst.addEventListener("click",this.statTrain);
        this.predbtn.addEventListener("click",this.evalNum);
        this.traininp.addEventListener("input",this.updRate);
        this.expbtn.addEventListener("click",this.exportNN);
        this.impbtn.addEventListener("click",this.importNN);
        this.trainsi.addEventListener("click",this.train);
        this.paint.canvas.parentNode.addEventListener("mousemove",()=>{if(this.paint.md) sys.evalNum();});
        this.status.innerText = "Idle, please upload files";
      }
      trainupl(e){
        this.status.innerText = "Processing files...";
        this.uploadPrompt(input=>{
          let uploaded = false;
          for(let i=0;i<input.files.length;i++){
            //alert(input.files[i].name);
            switch(input.files[i].name){
              case "train-labels.idx1-ubyte":{
                //alert("labels found")
                this.updFileStatus({trainls:"0%"});
                const fr = new FileReader();
                fr.onload = () => {
                  this.updFileStatus({trainls:"10%"});
                  const parser = new IDXReader(fr.result);
                  //alert(parser.getDimArr());
                  this.updFileStatus({trainls:"15%"});
                  //try{
                  this.traindat[0] = this.label2tensor(Array.from(parser.getTensor()));
                  this.updFileStatus();
                  //}catch(e){alert(e.stack)}
                }
                fr.readAsArrayBuffer(input.files[i]);
                uploaded = true;
                break;
              }
              case "train-images.idx3-ubyte":{
                //alert("images found")
                const fr = new FileReader();
                this.updFileStatus({trainis:"0%"});
                fr.onload = () => {
                  this.updFileStatus({trainis:"10%"});
                  const parser = new IDXReader(fr.result);
                  this.updFileStatus({trainis:"15%"});
                  //alert(parser.getDimArr());
                  //try{
                  this.traindat[1] = this.decon(parser.getTensor());
                  this.updFileStatus();
                  //}catch(e){alert(e.stack)}
                }
                fr.readAsArrayBuffer(input.files[i]);
                uploaded = true;
                break;
              }
            }
          }
          if(!uploaded){
            alert("Missing files!\n(Could be format mismatch or no files uploaded)");
          }
          this.status.innerText = "Idle, please upload files";
        });
      }
      testupl(e){
        this.status.innerText = "Processing files...";
        this.uploadPrompt(input=>{
          let uploaded = false;
          for(let i=0;i<input.files.length;i++){
            //alert(input.files[i].name);
            switch(input.files[i].name){
              case "t10k-labels.idx1-ubyte":{
                const fr = new FileReader();
                this.updFileStatus({testls:"0%"});
                fr.onload = () => {
                  this.updFileStatus({testls:"10%"});
                  const parser = new IDXReader(fr.result);
                  this.updFileStatus({testls:"15%"});
                  this.testdat[0] = this.label2tensor(Array.from(parser.getTensor()));
                  /*
                  try{
                    this.testdat[0] = this.label2tensor(Array.from(this.testdat[0]));
                  }catch(e){alert(e)};
                  alert(this.testdat[0][0]);
                  */
                  this.updFileStatus();
                }
                fr.readAsArrayBuffer(input.files[i]);
                uploaded = true;
                break;
              }
              case "t10k-images.idx3-ubyte":{
                const fr = new FileReader();
                this.updFileStatus({testis:"0%"});
                fr.onload = () => {
                  this.updFileStatus({testis:"10%"});
                  const parser = new IDXReader(fr.result);
                  this.updFileStatus({testis:"15%"});
                  this.testdat[1] = this.decon(parser.getTensor());
                  this.updFileStatus();
                }
                fr.readAsArrayBuffer(input.files[i]);
                uploaded = true;
                break;
              }
            }
          }
          if(!uploaded){
            alert("Missing files!\n(Could be format mismatch or no files uploaded)");
          }
          this.status.innerText = "Idle, please upload files";
        });
      }
      //You can't make this async due to change uncertainty
      uploadPrompt(callback){
        let finput = document.createElement("input");
        finput.type = "file";
        finput.setAttribute("multiple",true);
        finput.accept = ".idx1-ubyte,.idx3-ubyte";
        finput.addEventListener("change",()=>{
          callback(finput);
          finput.remove();
        });
        finput.click();
      }
      updFileStatus(options={}){
        //alert(this.traindat[1])
        this.trainstat.innerText = (options.trainls ?? (this.traindat[0] ? "✓" : "×")) + " train-labels.idx1-ubyte\n" + (options.trainis ?? (this.traindat[1] ? "✓" : "×")) + " train-images.idx3-ubyte";
        this.teststat.innerText = (options.testls ?? (this.testdat[0] ? "✓" : "×")) + " t10k-labels.idx1-ubyte\n" + (options.testis ?? (this.testdat[1] ? "✓" : "×")) + " t10k-images.idx3-ubyte";
      }
      decon(tensor){
        this.status.innerText = "Deconstructing tensor...";
        //excecute onupload.
        for(let i=0;i<tensor.length;i++){
          const narr = new Float32Array(tensor[i].length * tensor[i][0].length);
          for(let j=0;j<tensor[i].length;j++){
            for(let k=0;k<tensor[i][j].length;k++){
              narr[(j*tensor[i][0].length)+k] = tensor[i][j][k];
            }
          }
          tensor[i] = narr;
        }
        //No return needed cuz it's a ref.
        return tensor;
      }
      label2tensor(tensor){
        this.status.innerText = "Converting labels...";
        //excecute onupload
        for(let i=0;i<tensor.length;i++){
          const ntensor = new Uint8Array(10);
          ntensor[tensor[i]] = 1;
          tensor[i] = ntensor;
          //alert(ntensor);
        }
        return tensor;
      }
      updEngine(){
        this.status.innerText = "Updating engine...";
        //deep copy dumb stuff
        for(let i=0;i<this.trainMod.shape.length;i++){
          //for(let j=0;j<this.train.shape[i].weights;j++)
          this.engineMod.shape[i].weights = this.trainMod.shape[i].weights.slice();
          this.engineMod.shape[i].biases = this.trainMod.shape[i].biases.slice();
        }
      }
      train(){
        this.status.innerText = "Training...";
        //try{
        //alert(this.trainMod);
        this.epoch+=Math.ceil(this.traindat[0].length/15);
        const loss = this.trainMod.train([this.traindat[1],this.traindat[0],15],2);
        this.updEngine();
        this.traininfo.innerText = "Current Epoch: "+this.epoch.toString()+"\nLoss: "+loss.toString();
        //}catch(e){alert(e.stack)}
        this.status.innerText = "Idle, please upload files";
      }
      testEngine(){
        let sumloss = 0;
        for(let i=0;i<this.testdat[0].length;i++){
          sumloss += NeuralJS.Loss.mse(this.engineMod.forward(this.testdat[1][i]),this.testdat[0][i]);
        }
        return sumloss/this.testdat[0].length;
      }
      statTest(){
        this.status.innerText = "Starting test...";
        //alert(this.engineMod.forward(this.testdat[1][0]).length + " : " + this.testdat[0][0].length);
        //try{
        this.testinf.innerText = "Average Loss: " + this.testEngine().toString();
        //}catch(e){alert(e.stack)};
        this.status.innerText = "Idle, please upload files";
      }
      statTrain(){
        //try{
        ///*
        if(this.process < 0){
          //alert(this.trainint.value);
          this.process = setInterval(this.train,parseInt(this.trainint.value));
        }else{
          clearInterval(this.process);
          this.process = setInterval(this.train,parseInt(this.trainint.value));
        }
        //*/
        //}catch(e){alert(e.stack)}
      }
      stopTrain(){
        if(this.process >= 0){
          clearInterval(this.process);
          this.process = -1;
        }
      }
      evalNum(){
        //alert("hi")
        try{
        this.status.innerText = "Predicting number...";
        }catch(e){alert(e.stack)}
        //alert(this.traindat[1][0]);
        //try{
        const cvsdata = this.paint.ctx.getImageData(0,0,this.paint.canvas.width,this.paint.canvas.height);
        let prodata = new Float32Array(784);
        for(let y=0;y<this.paint.canvas.height;y++){
          for(let x=0;x<this.paint.canvas.width;x++){
            //red channel can be used as luminance cuz it's grayscale.
            const index = (y*28)+x;
            //console.log(cvsdata.data[(index*4)]);
            prodata[index] = cvsdata.data[(index*4)]/255; //Whoops went to infinity
          }
        }
        const outdat = this.engineMod.forward(prodata);
        let maxof = 0;
        for(let i=0;i<outdat.length;i++){
          outdat[i] > outdat[maxof] && (maxof=i);
        }
        //console.log(outdat);
        //console.log("Pred: " + maxof.toString());
        this.predhead.innerText = "Prediction: " + maxof.toString();
        let predstr = "";
        for(let i=0;i<outdat.length;i++){
          predstr += i.toString() + ": " + (outdat[i]*100).toString() + "%\n";
        }
        this.predinfo.innerText = predstr;
        /*
        let top = new Array(28);
        for(let i=0;i<28;i++){
          top[i] = prodata[i].toString();
        }
        alert(top);
        format correct?
        */
        //}catch(e){alert(e)}
        this.status.innerText = "Idle, please upload files";
      }
      updStats(){
        let outstr = "Activation: ";
        switch(this.trainMod.activation){
          case 0:
            outstr+="Sigmoid";
            break;
          case 1:
            outstr+="ReLU";
            break;
          case 2:
            outstr+="Leaky ReLU";
            break;
          case 3:
            outstr+="Hyperbolic Tangent";
            break;
          case 4:
            outstr+="Step";
            break;
          case 5:
            outstr+="ELU";
            break;
          default:
            outstr+="invalid";
        }
        outstr+="\nLoss: ";
        switch(this.trainMod.loss){
          case 0:
            outstr+="Mean Squared Error";
            break;
          case 1:
            outstr+="Cross Entropy";
            break;
          default:
            outstr+="invalid";
        }
        outstr+="\nOptimization: ";
        switch(this.trainMod.opti){
          case 0:
            outstr+="Stocastic Gradient Descent";
            break;
          case 1:
            outstr+="Batch Gradient Descent";
            break;
          case 2:
            outstr+="Mini Batch Gradient Descent";
            break;
          default:
            outstr+="invalid";
        }
        outstr+="\nOutput Activation: ";
        switch(this.trainMod.oActiv){
          case 0:
            outstr+="Softmax";
            break;
          case 1:
            outstr+="Linear";
            break;
          case 2:
            outstr+="Sigmoid";
            break;
          default:
            outstr+="invalid";
        }
        outstr+="\nHidden layer depth: "+(this.trainMod.shape.length-1).toString()+"\nParameters: ";
        let totalp = 0;
        for(let i=0;i<this.trainMod.shape.length;i++){
          totalp += this.trainMod.shape[i].weights.length + this.trainMod.shape[i].biases.length;
        }
        this.info.innerText = outstr+totalp.toString();
      }
      updRate(){
        this.trainMod.learnRate = parseFloat(this.traininp.value);
        //console.log(this.trainMod.learnRate);
      }
      exportNN(){
        //try{
        this.status.innerText = "Exporting MNIST...";
        const outdata = NeuralJS.File.exportNN(this.trainMod);
        const dwnelm = document.createElement("a");
        dwnelm.download = "mnist.nn";
        dwnelm.type = "application/octet-stream";
        dwnelm.href = URL.createObjectURL(new Blob([outdata]));
        document.body.appendChild(dwnelm);
        dwnelm.click();
        dwnelm.remove();
        this.status.innerText = "Idle, please upload files";
        //}catch(e){alert(e.stack)}
      }
      importNN(){
        const felm = document.createElement("input");
        felm.type = "file";
        felm.addEventListener("change",e=>{
          if(felm.files.length == 0){
            alert("File Error: No files found!");
            felm.remove();
            return;
          }else if(felm.files[0].name.substr(felm.files[0].name.length-3) != ".nn"){
            alert("File Error: File extension is not .nn!");
            felm.remove();
            return;
          }
          this.status.innerText = "Processing files...";
          //File processing problem!!! fixed
          const fr = new FileReader();
          fr.onload = ()=>{
            //alert("hi");
            //try{
            //alert(this.trainMod.shape[1].weights);
            const impnet = NeuralJS.File.importNN(fr.result);
            if(impnet){
              if(impnet.activation == this.trainMod.activation && impnet.oActiv == this.trainMod.oActiv){
                if(this.trainMod.shape.length != impnet.shape.length){
                  alert("Processing Error: Length Mismatch with file!");
                  felm.remove();
                  this.status.innerText = "Idle, please upload files";
                  return;
                }
                for(let i=0;i<this.trainMod.shape.length;i++){
                  //alert(this.trainMod.shape[i].biases.length.toString() + "=" + impnet.shape[i].biases.length.toString());
                  if(this.trainMod.shape[i].weights.length == impnet.shape[i].weights.length && this.trainMod.shape[i].biases.length == impnet.shape[i].biases.length){
                    this.trainMod.shape[i].weights = impnet.shape[i].weights;
                    this.trainMod.shape[i].biases = impnet.shape[i].biases;
                  }else{
                    alert("Processing Error: Length Mismatch with imported layer!");
                    felm.remove();
                    this.status.innerText = "Idle, please upload files";
                    return;
                  }
                }
                this.updEngine();
                this.status.innerText = "Idle, please upload files";
                //alert(this.trainMod.shape[1].weights);
              }else{
                alert("Processing Error: Activation Mismatch!");
                felm.remove();
                this.status.innerText = "Idle, please upload files";
              }
            }else{
              alert("Processing Error: Unsupported type or version!");
              felm.remove();
              this.status.innerText = "Idle, please upload files";
            }
            
            //}catch(e){alert(e.stack)}
          };
          fr.readAsArrayBuffer(felm.files[0]);
        });
        felm.click();
      }
    }
    
    function prettyArray(a){
      if(a.length){
        let s = "[";
        for(let i=0;i<a.length;i++){
          s += prettyArray(a[i]);
          if(i!=a.length-1){s += ","};
        };
        s += "]";
        return s;
      }else{
        return a.toString();
      };
    }
    let painter = new mfpaint(document.getElementById("controls").getElementsByClassName("canvascont")[0].children[0],document.getElementById("controls").getElementsByClassName("topConpaint")[0]);
    let sys = new Mnist(document.getElementById("mnistouttop"),document.getElementById("mnistoutbot"),painter);
    document.getElementById("testbtn").addEventListener("click",()=>{try{sys.train()}catch(e){alert(e.stack)}});
    document.getElementById("testbtn2").addEventListener("click",()=>{try{sys.evalNum()}catch(e){alert(e.stack)}});
    document.addEventListener("keydown",e=>{if(e.code=="Backquote" && e.ctrlKey){document.getElementById("tests").classList.toggle("thid");}});
    painter.topinp[0].addEventListener("click",sys.evalNum);
    painter.topinp[1].addEventListener("click",sys.evalNum);
    painter.topinp[2].addEventListener("click",sys.evalNum);
    painter.topinp[3].addEventListener("click",sys.evalNum);
</script></html>
